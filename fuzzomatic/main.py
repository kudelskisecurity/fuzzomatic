#!/usr/bin/env python3
import argparse
import datetime
import glob
import json
import os.path
import subprocess
import sys

import fuzzomatic.tools.utils
from fuzzomatic.tools import utils
from fuzzomatic import discovery
from fuzzomatic.approaches import (
    try_functions_approach,
    try_examples_approach,
    try_readme_approach,
    try_benches_approach,
    try_unit_tests_approach,
    try_unit_tests_with_function_approach,
)
from fuzzomatic.tools.constants import (
    DEFAULT_TARGET_NAME,
    FUZZOMATIC_RESULTS_FILENAME,
    EXIT_NOT_A_CARGO_PROJECT,
    EXIT_PROJECT_ALREADY_FUZZED,
    EXIT_PROJECT_DOES_NOT_BUILD,
    EXIT_OPENAI_API_KEY_ERROR,
)
from fuzzomatic.tools.llm import ask_llm, reset_ask_llm_counts, load_openai_api_key
from fuzzomatic.tools.runtime import evaluate_target, cleanup_corpus
from fuzzomatic.tools.utils import (
    get_codebase_name,
    git_clone,
    init_cargo_fuzz,
    check_virtual_manifest,
    detect_git_url,
)


def get_parser():
    prog_name = "fuzzomatic"
    parser = argparse.ArgumentParser(
        prog=prog_name,
        description="Automatically generate Rust fuzz targets from scratch",
    )
    parser.add_argument(
        "codebase_dir", help="Path to the codebase to generate a fuzz target for"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        dest="force",
        help=f"Run {prog_name} anyway. Even if project is already covered by oss-fuzz",
    )
    parser.add_argument(
        "--run",
        action="store_true",
        dest="run",
        help="Run the generated fuzz target. "
        "Note that running arbitrary code generated by AI is insecure.",
    )
    parser.add_argument(
        "--backtrack",
        action="store_true",
        dest="backtrack",
        help="If the build is successful, but at runtime, "
        "we determine that the target is not useful, "
        "backtrack and attempt the approaches that haven't been tried yet, "
        "until all approaches have been tried"
        "or a useful target is generated.",
    )
    parser.add_argument(
        "--approaches",
        nargs="+",
        dest="approaches",
        default=None,
        help="List of approaches to use",
    )

    return parser


def save_results(
    codebase_dir,
    fuzz_target_path,
    outcome,
    outcome_reason,
    tried_approaches,
    start_time,
):
    if fuzz_target_path is not None and os.path.exists(fuzz_target_path):
        with open(fuzz_target_path, "r") as f:
            fuzz_target_code = f.read()
    else:
        fuzz_target_code = None

    total_llm_calls = 0
    total_tokens = 0
    for approach_name, outcome, usage in tried_approaches:
        total_llm_calls += usage["llm_calls"]
        total_tokens += usage["total_tokens"]

    name = get_codebase_name(codebase_dir)
    git_url = utils.detect_git_url(codebase_dir)

    # successful approach
    successful_approach = None
    for approach_name, approach_outcome, _ in tried_approaches:
        if approach_outcome is True:
            successful_approach = approach_name
            break

    # runtime
    end_time = datetime.datetime.utcnow()
    duration: datetime.timedelta = end_time - start_time
    duration_seconds = duration.total_seconds()

    # create results
    results_path = os.path.join(codebase_dir, FUZZOMATIC_RESULTS_FILENAME)

    results = {
        "codebase_dir": codebase_dir,
        "name": name,
        "git_url": git_url,
        "fuzz_target_code": fuzz_target_code,
        "outcome": outcome,
        "outcome_reason": outcome_reason,
        "successful_approach": successful_approach,
        "tried_approaches": tried_approaches,
        "start_time": start_time.isoformat(),
        "end_time": end_time.isoformat(),
        "duration_seconds": duration_seconds,
        "total_llm_calls": total_llm_calls,
        "total_tokens": total_tokens,
    }

    # combine results due to backtracking
    if os.path.exists(results_path):
        with open(results_path, "r") as f:
            previous_results = json.loads(f.read())

            # outcome and reason
            previous_outcome = previous_results["outcome"]
            previous_outcome_reason = previous_results["outcome_reason"]
            previous_fuzz_target_code = previous_results["fuzz_target_code"]

            if outcome is not True and previous_outcome is True:
                results["outcome"] = previous_outcome
                results["outcome_reason"] = previous_outcome_reason
                results["fuzz_target_code"] = previous_fuzz_target_code

            # tried approaches
            previous_tried_approaches = previous_results["tried_approaches"]
            total_tried_approaches = []
            total_tried_approaches.extend(previous_tried_approaches)
            total_tried_approaches.extend(tried_approaches)
            results["tried_approaches"] = total_tried_approaches

            # successful approach
            if successful_approach is None:
                # combine successful approach in case it worked before, but fails now
                for ta, outcome, _ in total_tried_approaches:
                    if outcome is True:
                        successful_approach = ta
                results["successful_approach"] = successful_approach

            # total time
            previous_duration_seconds = previous_results["duration_seconds"]
            results["duration_seconds"] = duration_seconds + previous_duration_seconds

            # LLM calls
            previous_llm_calls = previous_results["total_llm_calls"]
            results["total_llm_calls"] = total_llm_calls + previous_llm_calls

            # total tokens
            previous_total_tokens = previous_results["total_tokens"]
            results["total_tokens"] = total_tokens + previous_total_tokens

    # save results to file
    with open(results_path, "w+") as fout:
        fout.write(json.dumps(results))

    print(f"Saved fuzzomatic results to: {results_path}")


def get_approaches(requested_approaches):
    approaches = []
    if requested_approaches is not None:
        for name, func in ENABLED_APPROACHES:
            if name in requested_approaches:
                approaches.append((name, func))
    else:
        approaches = ENABLED_APPROACHES
    return approaches


def generate_and_build(codebase_dir, git_url, approaches, force=False):
    start_time = datetime.datetime.utcnow()

    codebase_name = get_codebase_name(codebase_dir)
    try:
        if not force:
            print(f"Checking if {codebase_name} is not already in oss-fuzz")
            if discovery.is_project_to_be_skipped(codebase_dir, git_url):
                print(
                    "[WARNING] project is already covered "
                    "by oss-fuzz or fuzzing is in place. "
                    "Pass --force to overwrite."
                )
                print("Aborting")
                sys.exit(EXIT_PROJECT_ALREADY_FUZZED)

        # if approaches passed on cli, use those only
        fuzz_target_path, tried_approaches = autofuzz_codebase(
            codebase_dir, approaches=approaches
        )
    except SystemExit as e:
        # save results before exiting
        tried_approaches = []
        fuzz_target_path = utils.build_fuzz_target_path(
            codebase_dir, DEFAULT_TARGET_NAME
        )
        outcome_reason = None
        exit_code = e.code
        if exit_code == EXIT_NOT_A_CARGO_PROJECT:
            outcome_reason = "not_a_cargo_project"
        elif exit_code == EXIT_PROJECT_ALREADY_FUZZED:
            outcome_reason = "project_already_fuzzed"
        elif exit_code == EXIT_PROJECT_DOES_NOT_BUILD:
            outcome_reason = "project_does_not_build"
        elif exit_code == EXIT_OPENAI_API_KEY_ERROR:
            sys.exit(-1)

        save_results(
            codebase_dir,
            fuzz_target_path,
            False,
            outcome_reason,
            tried_approaches,
            start_time,
        )

        end_time = datetime.datetime.utcnow()
        duration = end_time - start_time
        return False, duration

    if fuzz_target_path is not None:
        print("Autofuzz successful!")
        print("Successfully generated a fuzz target that builds at: ")
        print(fuzz_target_path)

        # save results to a file in the codebase_dir
        save_results(
            codebase_dir,
            fuzz_target_path,
            True,
            "target_build_success",
            tried_approaches,
            start_time,
        )
        end_time = datetime.datetime.utcnow()
        duration = end_time - start_time
        return True, duration
    else:
        print("Failed to automatically generate a working fuzz target")
        print("No heuristic worked")
        save_results(
            codebase_dir,
            fuzz_target_path,
            False,
            "no_approach_worked",
            tried_approaches,
            start_time,
        )
        end_time = datetime.datetime.utcnow()
        duration = end_time - start_time
        return False, duration


def ensure_dependencies_available():
    required_external_commands = [
        ("semgrep", ["semgrep"]),
        ("cargo fuzz", ["cargo", "fuzz", "help"]),
    ]

    print("Checking external dependencies...")
    for cmd_name, cmd in required_external_commands:
        try:
            subprocess.check_call(
                cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL
            )
            print(f"[SUCCESS] {cmd_name}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(
                f"[FAILURE] {cmd_name} is a required dependency. "
                f"Fuzzomatic won't run without it."
            )
            print(
                "Make sure that the dependency is installed "
                "as explained in the README instructions"
            )
            print("Aborting...")
            sys.exit(-1)


def main(args=None):
    # reset LLM counter
    ask_llm.counter = 0

    if args is None:
        parser = get_parser()
        args = parser.parse_args()

    # load openai api key
    load_openai_api_key()

    # check required dependencies are available
    ensure_dependencies_available()

    very_start = datetime.datetime.utcnow()

    # if git URL, clone the repository
    git_url = None
    if args.codebase_dir.startswith("https://"):
        git_url = args.codebase_dir
        path = os.path.abspath(os.path.join(".", "git"))
        print("Code base appears to be a git URL. Trying to git clone...")
        codebase_dir = git_clone(args.codebase_dir, path)
        args.codebase_dir = codebase_dir
    else:
        git_url = detect_git_url(args.codebase_dir)

    build_and_run_once(args, git_url)

    if args.backtrack:
        backtrack(args, args.codebase_dir, git_url)

    very_end = datetime.datetime.utcnow()
    total_duration = very_end - very_start
    print(f"Total duration: {total_duration}")


def backtrack(args, codebase_dir, git_url):
    print("Starting backtracking loop")
    backtracking_count = 0
    while True:
        # read results from files
        r = read_codebase_results(args.codebase_dir)
        useful_targets = 0
        should_exit = True

        useful = None
        tried_approaches = None
        build_success = None
        has_untried_approaches = None
        untried_approaches = []

        if "outcome" in r:
            build_success = r["outcome"] is True

        if "runtime_useful" in r:
            useful = r["runtime_useful"]

            if useful:
                useful_targets += 1

        if "tried_approaches" in r:
            tried_approaches = r["tried_approaches"]
            tried_names = []
            for ta in tried_approaches:
                [name, _, _] = ta
                tried_names.append(name)

            enabled_approaches_names = []
            for name, _ in ENABLED_APPROACHES:
                enabled_approaches_names.append(name)

            all_approaches = set(enabled_approaches_names)
            tried_approaches = set(tried_names)

            untried_approaches = list(all_approaches - tried_approaches)

            if len(untried_approaches) > 0:
                has_untried_approaches = True
            else:
                has_untried_approaches = False

        if build_success is not None and build_success is True:
            if useful is not None and not useful:
                if has_untried_approaches is not None and has_untried_approaches:
                    # project doesn't have a useful target
                    # and there are still approaches to try
                    should_exit = False

        # exit condition
        if should_exit:
            break

        backtracking_count += 1

        print()
        print(f"{backtracking_count=}")

        print("Retrying with approaches:")
        print(untried_approaches)

        # re-run the build step, starting with the approaches not yet tried
        approaches = get_approaches(untried_approaches)
        generate_and_build(codebase_dir, git_url, approaches, force=True)

        # re-run the runtime step
        cleanup_corpus(codebase_dir)
        is_fuzz_target_useful, bug_found, error = evaluate_target(
            codebase_dir, max_total_time_seconds=10
        )
        print(f"{is_fuzz_target_useful=}")
        print(f"{bug_found=}")
        if is_fuzz_target_useful:
            # project is now useful
            print("[SUCCESS] Backtracking made the target become useful.")

        # end while True

    print()
    print("Backtracking completed")
    print(f"Backtrack count: {backtracking_count}")


def build_and_run_once(args, git_url):
    # check if results file already exists
    target_results = read_codebase_results(args.codebase_dir)

    skip_build = False
    skip_run = False
    build_successful = False
    if target_results is not None and "runtime_useful" in target_results:
        # skip whole initial step
        print(
            "Skipping whole initial step. Autofuzz already generated a useful target."
        )
        skip_run = True
    elif target_results is not None and "outcome" in target_results:
        # skip the build
        skip_build = True
        print("Skipping build")
        build_successful = target_results["outcome"]
    if (not skip_build and not skip_run) or args.force:
        print("Building target")
        # run build step once
        approaches = get_approaches(args.approaches)
        build_successful, duration = generate_and_build(
            args.codebase_dir, git_url, approaches, force=args.force
        )
        print(f"Outcome: {build_successful}")

    # run runtime step once
    if (
        not build_successful or skip_run or (not args.run and not args.backtrack)
    ):  # skip failed builds
        print("Skipping runtime...")
    else:
        print(f"Running target: {args.codebase_dir}")
        cleanup_corpus(args.codebase_dir)

        is_fuzz_target_useful, bug_found, error = evaluate_target(
            args.codebase_dir, max_total_time_seconds=10
        )
        print(f"{is_fuzz_target_useful=}")
        print(f"{bug_found=}")


def read_codebase_results(codebase_dir):
    results_file_path = os.path.join(codebase_dir, FUZZOMATIC_RESULTS_FILENAME)
    target_results = None
    if os.path.exists(results_file_path):
        with open(results_file_path) as f:
            target_results = json.loads(f.read())
    return target_results


def autofuzz_subdirs(codebase_dir, target_name, approaches=[]):
    files = glob.glob(f"{codebase_dir}/*")
    tried_approaches = []
    for f in files:
        # check that the subdir is not fuzzed
        is_fuzzed = discovery.is_project_already_fuzzed(f)
        if os.path.isdir(f) and not is_fuzzed:
            print(f"Retrying with subdir: {f}")
            try:
                fuzz_target, tried_approaches = autofuzz_codebase(
                    f,
                    target_name=target_name,
                    virtual_manifest=True,
                    approaches=approaches,
                )
            except SystemExit:
                print(f"Failed to process subdir: {f}")
                print("Moving on")
                fuzz_target = None
            if fuzz_target is not None:
                return fuzz_target, tried_approaches
        else:
            print(f"Skipping subdir: {f}")

    return None, tried_approaches


def is_project_building_by_default(codebase_dir):
    cmd = ["cargo", "check"]

    try:
        subprocess.check_call(cmd, cwd=codebase_dir)
        return True
    except subprocess.CalledProcessError as e:
        print("Project does not build by default")
        print(e)
        return False


def autofuzz_codebase(
    codebase_dir, target_name=DEFAULT_TARGET_NAME, virtual_manifest=False, approaches=[]
):
    tried_approaches = []

    success = init_cargo_fuzz(codebase_dir, target_name)
    if success:
        check_project_builds_or_exit(codebase_dir)
    else:
        print("Failed to init cargo fuzz")

        # check whether it's a virtual manifest
        is_virtual_manifest = check_virtual_manifest(codebase_dir)
        if is_virtual_manifest:
            return autofuzz_subdirs(
                codebase_dir, target_name=target_name, approaches=approaches
            )
        else:
            print("Aborting... could not cargo fuzz init, and not a virtual manifest")
            raise SystemExit(EXIT_NOT_A_CARGO_PROJECT)

    # add dependencies from the parent Cargo.toml file to the fuzz Cargo project
    fuzzomatic.tools.utils.add_parent_dependencies(codebase_dir)
    # also add the arbitrary crate for target functions with multiple arguments
    utils.add_fuzz_dependency(codebase_dir, "arbitrary@1", features=["derive"])

    for approach_name, approach_function in approaches:
        print("=" * 40)
        print(f"ATTEMPTING APPROACH: {approach_name}")
        print("=" * 40)

        # reset counts per approach
        reset_ask_llm_counts()

        # attempt approach
        success, fuzz_target_path = approach_function(
            codebase_dir, target_name=target_name, virtual_manifest=virtual_manifest
        )

        outcome = success

        usage = {
            "prompt_tokens": ask_llm.prompt_tokens,
            "completion_tokens": ask_llm.completion_tokens,
            "total_tokens": ask_llm.total_tokens,
            "llm_calls": ask_llm.counter,
        }
        tried_approaches.append((approach_name, outcome, usage))
        if success:
            return fuzz_target_path, tried_approaches

    return None, tried_approaches


def check_project_builds_or_exit(codebase_dir):
    print("Checking if project builds by default...")
    default_builds = is_project_building_by_default(codebase_dir)
    print(f"{default_builds=}")
    # if the project does not build by default, don't bother
    if not default_builds:
        raise SystemExit(EXIT_PROJECT_DOES_NOT_BUILD)


ENABLED_APPROACHES = [
    ("functions", try_functions_approach),
    ("readme", try_readme_approach),
    ("examples", try_examples_approach),
    ("unit_tests", try_unit_tests_approach),
    ("unit_tests_with_function", try_unit_tests_with_function_approach),
    ("benches", try_benches_approach),
]

if __name__ == "__main__":
    main()
